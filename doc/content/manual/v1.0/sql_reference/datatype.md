데이터 타입
===========

수치형 데이터 타입
------------------

정수 또는 실수를 저장하기 위해 다음의 수치형 데이터 타입을 지원한다.

<table>
<colgroup>
<col width="20%" />
<col width="10%" />
<col width="25%" />
<col width="25%" />
<col width="18%" />
</colgroup>
<thead>
<tr class="header">
<th>타입</th>
<th>Bytes</th>
<th>최소값</th>
<th>최대값</th>
<th>정확/근사치</th>
</tr>
</thead>
<tbody>
<tr class="even">
<td><strong>INTEGER</strong>, <strong>INT</strong></td>
<td>4</td>
<td>-2,147,483,648</td>
<td>+2,147,483,647</td>
<td>정확한 수치</td>
</tr>
<tr class="odd">
<td><strong>BIGINT</strong></td>
<td>8</td>
<td>-9,223,372,036,854,775,808</td>
<td>+9,223,372,036,854,775,807</td>
<td>정확한 수치</td>
</tr>
<tr class="even">
<td><strong>NUMERIC</strong>, <strong>DECIMAL</strong></td>
<td>16</td>
<td><p>정밀도 <em>p</em>: 1</p>
<p>스케일 <em>s</em>: 0</p></td>
<td><p>정밀도 <em>p</em>: 38</p>
<p>스케일 <em>s</em>: 38</p></td>
<td>정확한 수치</td>
</tr>
<tr class="even">
<td><strong>DOUBLE</strong>, <strong>DOUBLE PRECISION</strong></td>
<td>8</td>
<td>-1.7976931348623157E+308 (ANSI/IEEE 754-1985 표준)</td>
<td>+1.7976931348623157E+308 (ANSI/IEEE 754-1985 표준)</td>
<td>근사치 부동소수점: 15자리</td>
</tr>
</tbody>
</table>

수치형 데이터 타입은 정확한(exact) 타입과 근사치(approximate) 타입으로 구분된다. 정확한 수치형 데이터 타입(**INT**, **BIGINT**, **NUMERIC**)은 정확하고 일관된 값을 가져야 하는 경우에 사용된다. 근사치 수치형 데이터 타입(**DOUBLE**)은 리터럴 값이 같아도 시스템에 따라 다르게 해석될 수 있으므로 주의한다.

Rye는 수치형 데이터 타입에 대해 UNSIGNED 타입을 지원하지 않는다.

**정밀도와 스케일(Precision and Scaling)**

 숫자 데이터 타입의 정밀도(precision)는 그 값이 유지할 수 있는 유효한 자릿수로 정의된다. 이는 정확한 수치형이든 근사치 수치형이든 마찬가지이다.

 스케일(scale)은 소수점 이하의 자릿수를 나타내는데, 정확한 수치형에서만 의미가 있다. 정확한 수치형으로 선언된 타입은 항상 고정된 정밀도와 스케일을 갖게 된다. **NUMERIC** (또는 **DECIMAL**) 데이터 타입은 항상 최소한 한 자리의 정밀도를 갖는다. 스케일의 범위는 0과 선언된 정밀도 사이여야 한다. 스케일이 정밀도보다 클 수는 없다. **INTEGER** 나 **BIGINT** 데이터 타입에서는 스케일은 0이고(즉, 소수점 이하가 없음), 정밀도는 시스템에 의해 고정된다.

**수치형 리터럴(Numeric Literals)**

 수치형 값을 입력하기 위해서는 특별한 기호가 사용될 수 있는데, 플러스(+)는 양수를, 마이너스(-)는 음수를 나타내는 데 사용한다. 과학용 표기법이 사용될 수도 있다. 수치형 리터럴로 표현 가능한 최대 정밀도는 255이다.

**수치형 변환(Numeric Coercions)**

 모든 수치형 데이터 타입은 상호 비교 가능하고, 이를 위해 서로 공통된 수치형 데이터 타입으로 자동 변환이 이루어진다. 명시적인 변환은 **CAST** 연산자를 이용해야 한다. 서로 다른 수치형 데이터가 서로 정렬되거나, 수식에서 계산될 때에는 시스템에 의하여 자동으로 변환된다. 예를 들어, **DOUBLE** 타입의 값과 **INTEGER** 타입의 값을 더하게 되면, 시스템이 자동적으로 **INTEGER** 값을 가장 근사한 **DOUBLE** 값으로 변환한 후 덧셈을 수행한다.

 다음은 **DOUBLE** 타입 값과 **INTEGER** 타입 값을 더하는 경우 **DOUBLE** 타입 값을 출력하는 예이다.

``` sql
 CREATE GLOBAL TABLE tbl (id INT PRIMARY KEY, a INT, b DOUBLE);
 INSERT INTO tbl VALUES (1, 10, 5.5);
 SELECT a + b FROM tbl;
```
```
  a+b    
=========
  15.5   
```

 다음은 두 개의 정수 값을 더하는 경우 결과 값도 **INTEGER** 타입이 되기 때문에 오버플로우(overflow) 에러가 발생하는 예이다.

``` sql
 SELECT 100000000*1000000;
```
```
ERROR: Overflow occurred in multiplication context.
```

 위와 같은 경우 어느 한 쪽의 타입을 **BIGINT**로 명시하면, **BIGINT**로 결과 값을 결정하고, 정상적인 결과를 출력한다.

``` sql
 SELECT CAST(100000000 AS BIGINT)*1000000;
```
```
  cast(100000000 as bigint)*1000000   
======================================
  100000000000000                     
```

### INT, INTEGER

**INTEGER** 데이터 타입은 정수 표현을 위해 사용하며, 표현할 수 있는 값의 범위는 -2,147,483,648에서 +2,147,483,647이다. 큰 정수를 표현하기 위해 **BIGINT**를 사용할 수 있다.

-   **INTEGER**와 **INT**는 같은 의미로 사용된다.
-   **INT** 타입에 실수가 입력되면, 소수점 아래 숫자가 반올림되어 정수값이 저장된다.
-   이 타입의 칼럼에 **DEFAULT** 속성이 지정될 수 있다.

```
    INTEGER에 8934를 지정하면 8934가 저장됨.
    INTEGER에 7823467를 지정하면 7823467이 저장됨.
    INTEGER에 89.8를 지정하면 90이 저장됨(소수점 뒤의 수치는 반올림됨).
    INTEGER에 3458901122를 지정하면 오류가 발생함(표현 가능 범위를 초과하면 오류 발생).
```

### SHORT, SMALLINT

**SMALLINT** 는 **INTEGER** 의 별칭이다.

### BIGINT

**BIGINT** 데이터 타입은 큰 정수 표현을 위해 사용되며, 표현할 수 있는 값의 범위는 -9,223,372,036,854,775,808에서 9,223,372,036,854,775,807이다.

-   **BIGINT** 타입에 실수가 입력되면, 소수점 아래 숫자가 반올림되어 정수값이 저장된다.
-   정밀도와 표현할 수 있는 범위를 기준으로는 다음과 같이 정렬할 수 있다.

    **INTEGER** ⊂ **BIGINT** ⊂ **NUMERIC**

-   이 타입의 칼럼에 **DEFAULT** 속성이 지정될 수 있다.

```
    BIGINT에 8934를 지정하면 8934가 저장됨.
    BIGINT에 89.1을 지정하면 89가 저장됨.
    BIGINT에 89.8을 지정하면 90이 저장됨(소수점 뒤의 수치는 반올림됨).
    BIGINT에 3458901122를 지정하면 3458901122가 저장됨.
```

### NUMERIC, DECIMAL

**NUMERIC** 또는 **DECIMAL** 데이터 타입은 고정 소수점 숫자를 표현하기 위해 사용되며, 다음과 같이 전체 자리 수(정밀도)와 소수점 아래 자릿수(스케일)을 옵션으로 지정하여 정의할 수 있다. 정밀도 *p*의 최소값은 1이고 최대값은 38이며, 정밀도 *p*가 생략되면 기본값은 15이므로, 정수부가 15자리를 초과하는 데이터를 입력할 수 없다. 또한, 스케일 *s*가 생략되면 스케일의 기본값은 0이므로 소수점 아래 첫째 자리에서 반올림한 정수를 반환한다.

```
    NUMERIC [(p[, s])]
```

-   정밀도는 반드시 스케일 이상이어야 한다.
-   정밀도는 (데이터의 정수부 자리 수 + 스케일) 이상이 되도록 지정한다.
-   **NUMERIC**과 **DECIMAL**, 그리고 **DEC**는 같은 의미로 사용된다.
-   **NUMERIC** 타입끼리 연산한 결과 값의 정밀도와 스케일이 어떻게 달라지는지 확인하려면 [수치형 데이터 타입의 산술 연산과 타입 변환](functions/arithmetic_op.md#수치형-데이터-타입의-산술-연산과-타입-변환)을 참고한다.
-   이 타입의 칼럼에 **DEFAULT** 속성이 지정될 수 있다.

```
    NUMERIC에 12345.6789를 지정하면 12346이 저장됨(스케일 기본값은 0이므로 소수점 아래 첫째 자리에서 반올림함).
    NUMERIC(4)에 12345.6789를 지정하면 오류가 발생함(정밀도는 데이터의 정수부 자릿수 이상이어야 함).
    NUMERIC(3,4)를 선언하면 오류가 발생함(정밀도는 스케일 이상이어야 함).
    NUMERIC(4,4)에 0.123456789를 지정하면 .1235가 저장됨(소수점 아래 다섯째 자리에서 반올림함).
    NUMERIC(4,4)에 -0.123456789를 지정하면 -.1235가 저장됨(소수점 아래 다섯째 자리에서 반올림한 후, - 부호를 붙임).
```

### FLOAT, REAL

**FLOAT** 는 **DOUBLE** 의 별칭이다.

### DOUBLE, DOUBLE PRECISION

**DOUBLE** 데이터 타입은 부동 소수점 숫자를 표현하기 위해 사용된다.

정규 값(normalized value)으로 표현할 수 있는 값의 범위는 -1.7976931348623157E+308에서 -2.2250738585072014E-308, 0, 그리고 2.2250738585072014E-308에서 1.7976931348623157E+308이며, 이 범위를 벗어나서 0에 가까운 값은 비정규 값(denormalized value)으로 표현한다. 이는 ANSI/IEEE 754-1985 표준을 준수한다.

정밀도를 지정할 수 없으며, 이 타입이 지정된 데이터는 이중 정밀도(double-precision, 15자리의 유효 숫자)로 표현된다.

**DOUBLE** 데이터 타입은 15자리의 유효 자릿수를 넘는 입력 값에 대해 근사치를 저장하는 타입이므로 유효 자릿수를 넘어서는 정확한 값을 지정할 때에는 사용하지 않도록 주의한다.

-   **DOUBLE**의 유효 자리 수는 15자리이다.
-   **DOUBLE** 타입은 근사치 데이터를 저장하므로 데이터 비교 시 주의해야 한다.
-   **DOUBLE**과 **DOUBLE PRECISION**은 같은 의미로 사용된다.
-   이 타입의 칼럼에 **DEFAULT** 속성이 지정될 수 있다.

```
    DOUBLE에 1234.56789를 입력하면 1234.56789가 저장되고, 1.234567890000000e+03이 출력된다.
    DOUBLE에 9007199254740993을 입력하면 9007199254740992가 저장되고, 9.007199254740992e+15가 출력된다.
```

날짜/시간 데이터 타입
---------------------

날짜/시간 데이터 타입은 날짜, 시간 혹은 이 두 가지를 모두 표현할 때 사용하는 데이터 타입으로 다음과 같은 데이터 타입을 지원한다.

<table>
<colgroup>
<col width="9%" />
<col width="7%" />
<col width="20%" />
<col width="23%" />
<col width="38%" />
</colgroup>
<thead>
<tr class="header">
<th>타입</th>
<th>bytes</th>
<th>최소값</th>
<th>최대값</th>
<th>비고</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>DATE</strong></td>
<td>4</td>
<td>0001년 1월 1일</td>
<td>9999년 12월 31일</td>
<td>예외적으로 DATE '0000-00-00'을 입력할 수 있다.</td>
</tr>
<tr class="even">
<td><strong>TIME</strong></td>
<td>4</td>
<td>00시 00분 00초</td>
<td>23시 59분 59초</td>
<td></td>
</tr>
<tr class="odd">
<td><strong>DATETIME</strong></td>
<td>8</td>
<td>0001년 1월 1일 0시 0분 0.000초</td>
<td>9999년 12월 31일 23시 59분 59.999초</td>
<td>예외적으로 DATETIME '0000-00-00 00:00:00'을 입력할 수 있다.</td>
</tr>
</tbody>
</table>

**범위와 해상도(Range and Resolution)**

-   시간 값의 표현은 기본적으로 24시간 시스템에 의하여 그 범위가 결정된다. 날짜는 그레고리력(Gregorian calendar)을 따른다. 이 두 제약 사항을 벗어나는 값이 날짜나 시간으로 입력되면 오류가 발생한다.
-   **DATE** 중 연도의 범위는 0001~9999 AD이다.
-   연도를 두 자리만 표기하면, 00~69는 2000~2069로 변환되고, 70~99는 1970~1999로 변환된다.
-   날짜, 시간과 관련된 연산은 시스템의 반올림 시스템에 따라 결과가 달라질 수 있다. 이러한 경우, 시간과 타임스탬프는 가장 근접한 초를 최소 해상도로, 날짜는 가장 근접한 날짜를 최소 해상도로 하여 결정된다.

**변환(Coercion)**

날짜/시간 데이터 타입의 값은 서로 똑같은 항목을 가지고 있는 경우에만 **CAST** 연산자를 이용한 명시적인 변환이 가능하며, 묵시적 변환은 [묵시적 타입 변환](#묵시적-타입-변환)을 참고한다. 아래의 표는 명시적 변환이 가능한 타입을 설명한다.

**명시적 변환**

FROM \ TO	| DATE	| TIME	| DATETIME
--- |--- |--- | ---
DATE | -| X | O
TIME | X | - | X
DATETIME | O | O | -

**DATE**, **DATETIME** 타입의 연, 월, 일에는 0을 입력할 수 없으나, 예외적으로 날짜와 시간이 모두 0인 값은 허용한다. 해당 타입의 칼럼에 대한 질의 수행 시 인덱스가 있으면 이 값을 사용할 수 있다는 점에서 **NULL** 대신 사용하면 유용하다.

-   **DATE**, **DATETIME** 타입이 인자인 일부 함수는 인자의 날짜와 시간 값이 모두 0이면 에러를 반환한다.
-   **DATE**, **DATETIME** 타입을 반환하는 함수들은 날짜와 시간 값이 모두 0인 값을 반환할 수 있지만 JAVA 응용 프로그램에서는 이러한 값을 Date 객체에 저장할 수 없다. 따라서 연결 URL 문자열의 zeroDateTimeBehavior 속성(Property) 설정에 따라서 예외로 처리하거나 **NULL**을 반환하거나 또는 최소값을 반환한다(이에 관한 자세한 내용은 [연결설정](api/jdbc.html#연결-설정) 참고).

### DATE

**DATE** 데이터 타입은 연도(*yyyy*), 월(*mm*), 일(*dd*)을 표현하며, 지원 범위는 '0001-01-01'에서 '9999-12-31'까지이다. 연도는 생략 가능하며, 생략될 경우 현재 시스템의 연도 값이 자동으로 지정된다. 입력 형식은 다음과 같다.
```
    date'[yyyy-]mm-dd'
```

-   모든 항목은 정수 형태로 입력되어야 한다.
-   문자열 타입의 데이터를 **DATE** 타입으로 변환하는 함수는 `TO_DATE()` 이다.
-   연, 월, 일에는 0을 입력할 수 없으나 예외적으로 연, 월, 일이 모두 0인 '0000-00-00'은 입력할 수 있다.
-   이 타입의 칼럼에 **DEFAULT** 속성이 지정될 수 있다.

### TIME

**TIME** 데이터 타입은 시각(*hh*), 분(*mi*), 초(*ss*) 를 표현하며, 지원 범위는 '00:00:00'에서 '23:59:59'까지이다. 초는 생략 가능하며, 생략될 경우 0초로 지정된다. 입력 형식은 12시간 표기법(AM/PM표기법) 또는 24시간 표기법이 모두 허용되며, 다음과 같이 작성한다.
```
    time'hh:mi[:ss] [am | pm]'
```

-   모든 항목은 정수로 입력되어야 한다.
-   JDBC 응용 프로그램은 24시간 표기법으로 시간 값을 출력한다.
-   24시간 표기법으로 시간 값을 입력할 때에도 AM/PM을 지정할 수 있으며, 이때 시간 값과 지정된 AM 또는 PM이 일치하지 않으면 오류가 발생한다.
-   모든 시간 값은 데이터베이스에는 24시간 표기법으로 저장된다.
-   문자열 타입의 데이터를 **TIME** 타입으로 변환하는 함수는 `TO_TIME()` 이다.
-   이 타입의 칼럼에 **DEFAULT** 속성이 지정될 수 있다.

```
    TIME'00:00:00'은 '12:00:00 AM'으로 출력된다.
    TIME'1:15'는 '01:15:00 AM'으로 간주된다.
    TIME'13:15:45'는 '01:15:45 PM'으로 간주된다.
    TIME'13:15:45 pm'은 정상적으로 저장된다.
    TIME'13:15:45 am'은 오류가 발생한다(주어진 시간 값과 AM/PM이 불일치).
```

### DATETIME

**DATETIME** 타입은 날짜(년, 월, 일)와 시간(시, 분, 초, 밀리초)을 결합한 데이터 값을 표현하며, GMT로 0001-01-01 00:00:00.000부터 9999-12-31 23:59:59.999까지 표현할 수 있다. **DATETIME** 타입 데이터의 입력 형식은 다음과 같다.
```
    datetime'hh:mi[:ss[.msec]] [am|pm] mm/dd[/yyyy]'
    datetime'hh:mi[:ss[.msec]] [am|pm] [yyyy-]mm-dd'
    datetime'mm/dd[/yyyy] hh:mi[:ss[.ff]] [am|pm]'
    datetime'[yyyy-]mm-dd hh:mi[:ss[.ff]] [am|pm]'
```

-   모든 항목은 정수로 입력되어야 한다.
-   연도를 생략하면 기본값으로 현재 연도가 지정되고, 시간 값(시/분/초/밀리초)를 생략하면 12:00:00.000 AM으로 지정된다.
-   시스템의 현재 타임스탬프 값은 `SYS_DATETIME` (또는 `SYSDATETIME`, `CURRENT_DATETIME`, `CURRENT_DATETIME()`, `NOW()`)를 이용하여 **DATETIME** 타입에 저장할 수 있다.
-   문자열 타입의 데이터를 **DATETIME** 타입으로 변환하는 함수는 `TO_DATETIME()` 이다.
-   연, 월, 일에는 0을 입력할 수 없으나 예외적으로 연, 월, 일, 시, 분, 초가 모두 0인 '0000-00-00 00:00:00'은 입력할 수 있다.
-   이 타입의 칼럼에 **DEFAULT** 속성이 지정될 수 있다.

### 문자열을 날짜/시간 타입으로 CAST

#### 날짜/시간 타입 문자열 권장 형식

`CAST()` 연산자를 사용하여 문자열을 날짜/시간 타입으로 변환할 때에는 문자열을 다음과 같은 형식으로 작성하는 것을 권장한다. 참고로, CAST 연산자에서 사용하는 날짜/시간 문자열 형식은 DB 생성 시 지정하는 로캘의 영향을 받지 않는다.

또한, `TO_DATE()`, `TO_TIME()`, `TO_DATETIME()` 함수에서 문자열에 대한 날짜/시간 형식을 생략하는 경우에도 날짜/시간 문자열 형식을 아래와 같이 작성한다.

-   **DATE** 타입
```
        YYYY-MM-DD
```

-   **TIME** 타입
```
        HH:MI:SS [AM|PM]
```

-   **DATETIME** 타입
```
        YYYY-MM-DD HH:MI:SS[.msec] [AM|PM]
```

#### 날짜/시간 타입 문자열 허용 형식

`CAST()` 연산자는 날짜/시간 문자열에 대해 아래와 같은 형식을 허용한다.

**DATE 문자열 허용 형식**

```
     [year sep] month sep day
```

-   2011-04-20 : 2011년 4월 20일
-   04-20 : 올해 4월 20일

구분자(*sep*)를 사용하지 않을 때에는 다음과 같은 형식으로 인식한다. 연도는 한 자리, 두 자리, 네 자리를 허용하고, 월은 한 자리, 두 자리를 허용한다. 일은 항상 두 자리를 입력해야 한다.
```
     YYYYMMDD
     YYMMDD
     YMMDD
     MMDD
     MDD
```

-   20110420 : 2011년 4월 20일
-   110420 : 2011년 4월 20일
-   420 : 올해 4월 20일

**TIME 문자열 허용 형식**

```
     [hour]:min[:[sec]][.[msec]] [am|pm]
```

-   09:10:15.359 am : 오전 9시 10분 15초(0.359초는 버림)
-   09:10:15 : 오전 9시 10분 15초
-   09:10 : 오전 9시 10분
-   :10 : 오전 12시 10분

```
     [[[[[[Y]Y]Y]Y]M]MDD]HHMISS[.[msec]] [am|pm]
```

-   20110420091015.359 am : 오전 9시 10분 15초
-   0420091015 : 오전 9시 10분 15초

```
     [H]HMMSS[.[msec]] [am|pm]
```

-   091015.359 am : 오전 9시 10분 15초
-   91015 : 오전 9시 10분 15초

```
     [M]MSS[.[msec]] [am|pm]
```

-   1015.359 am : 오전 12시 10분 15초
-   1015 : 오전 12시 10분 15초

```
     [S]S[.[msec]] [am|pm]
```

-   15.359 am : 오전 12시 0분 15초
-   15 : 오전 12시 0분 15초

**DATETIME 문자열 허용 형식**

```
     [year sep] month sep day [sep] [sep] hour [sep min[sep sec[.[msec]]]]
```

-   04-20 09 : 올해 4월 20일 오전 9시

```
     year sep month sep day sep hour [sep min[sep sec[.[msec]]]]
```

-   2011-04-20 09 : 2011년 4월 20일 오전 9시

```
     YYMMDDH (시간이 한 자리 수일 때에만 허용)
```

-   1104209 : 2011년 4월 20일 오전 9시

```
     YYMMDDHHMI[SS[.msec]]
```

-   1104200910.359 : 2011년 4월 20일 오전 9시 10분(0.359초는 버림)
-   110420091000.359 : 2011년 4월 20일 오전 9시 10분 0.359초

```
     YYYYMMDDHHMISS[.msec]
```

-   201104200910.359 : 2020년 11월 4일 오후 8시 9분 10.359초
-   20110420091000.359 : 2011년 4월 20일 오전 9시 10분 0.359초

**규칙**

*msec*은 밀리초를 나타내는 일련의 숫자이다. 앞에서 네 번째 자리부터 이후의 숫자는 무시된다. 값 사이를 구분하는 구분자의 규칙은 다음과 같다.

-   **TIME** 문자열은 시간 구분자로 항상 하나의 콜론(:)을 사용해야 한다.
-   **DATE** 와 **DATETIME** 문자열은 구분자 없이 연속된 숫자로 나타낼 수 있고, **DATETIME** 문자열은 시간과 날짜를 공백으로 구분할 수 있다.
-   입력 문자열 안에서 구분자들은 동일해야 한다.

날짜 부분의 문자열에는 다음 규칙이 적용된다.

-   연도는 구문이 허용하는 한 생략할 수 있다.
-   연도를 두 자리로 입력하면 1970년~2069년 범위의 연도를 나타낸다. 즉, YY&lt;70 이면 2000+YY으로 처리하고, YY&gt;=70이면 1900+YY으로 처리한다. 한 자리나 세 자리, 네 자리 숫자로 연도를 입력하면 해당 숫자 그대로를 나타낸다.
-   문자열 앞뒤의 공백과 뒤의 문자열은 무시된다. **DATETIME**, **TIME** 문자열을 위한 am/pm 지정자는 시간 값의 일부로 인식하지만, 공백이 아닌 문자가 뒤에 붙으면 am/pm 지정자로 인식되지 않는다.

Rye의 **DATETIME** 타입은 **DATE** 타입과 **TIME** 타입에 밀리초(milliseconds)가 더해져서 구성된다. 입력 문자열은 날짜(**DATE** 문자열), 시간(**TIME** 문자열), 혹은 둘 다(**DATETIME** 문자열) 포함할 수 있다. 특정 타입의 데이터를 보유한 문자열은 다른 타입으로도 변환될 수 있으며 다음과 같은 규칙이 적용된다.

-   **DATE** 문자열을 **DATETIME** 타입으로 변환하면 시간 값은 '00:00:00'이 된다.
-   **TIME** 문자열을 **DATETIME** 타입으로 변환하면 콜론(:)이 날짜 구분자로 인식되어 **TIME** 문자열이 날짜를 나타내는 문자열로 인식되고, 시간 값은 '00:00:00'이 된다.
-   **DATETIME** 문자열을 **DATE** 타입으로 변환하면 결과값에서 시간 부분은 무시되지만, 시간 입력값의 형식은 유효해야 한다.
-   **DATETIME** 문자열을 **TIME** 타입으로 변환할 수 있지만, 다음과 같은 규칙이 적용된다.
     -   문자열에 있는 날짜와 시간은 최소한 하나의 공백에 의해 구분되어야 한다.
     -   결과값에서 날짜 부분은 무시되지만, 날짜 입력값의 형식이 유효해야 한다.
     -   날짜 부분의 연도가 4자리 이상이거나(0으로 시작할 수 있음), 시간 부분이 최소한 시와 분(\[H\]H:\[M\]M)을 포함해야 한다. 그렇지 않으면 날짜 부분이 \[MM\]SS 포맷의 **TIME** 타입으로 인식되고, 뒤이어 나오는 문자열은 무시된다.
-   **DATETIME** 문자열의 각 단위(년, 월, 일, 시, 분, 초) 중 하나가 999999보다 크면, 숫자가 아닌 것으로 인식하여 해당 단위가 포함된 문자열이 무시된다. 예를 들어 '2009-10-21 20:9943:10'은 분 단위의 값이 범위를 벗어나므로 에러가 발생한다. 그러나 '2009-10-21 20:1000123:10'이 입력되면 '2009'를 MMSS 포맷의 **TIME** 타입으로 인식하여 **TIME**'00:20:09'를 반환한다.
-   시간 부분이 있는 모든 입력 문자열은 변환 시 \[*msec*\] 을 허용하지만, **DATETIME** 타입만 그 값을 유지한다. **DATE**, **TIME** 와 같은 타입으로 변환하면 *msec* 값을 버린다.
-   **DATETIME**, **TIME** 문자열에서의 모든 변환은 시간 값 뒤에 나오는 영문 로캘(locale) 또는 서버의 현재 로캘로 쓰여진 am/pm 지정자를 허용한다.

``` sql
 SELECT CAST('420' AS DATE);
```
```
  cast('420' as date)   
========================
  '2017-04-20'          
```
``` sql
 SELECT CAST('91015' AS TIME);
```
```
  cast('91015' as time)   
==========================
  '09:10:15'              
```
``` sql
 SELECT CAST('110420091035.359' AS DATETIME);
```
```
  cast('110420091035.359' as datetime)   
=========================================
  '2011-04-20 09:10:35.359'              
```

바이너리 데이터 타입
------------------

바이너리는 0과 1로 이루어진 이진 값의 순열(sequence)이다.

-   가변길이 비트열(**VARBINARY**)
-   **BINARY** (*n*) 은 **VARBINARY** (*n*) 의 별칭이다.

칼럼의 타입으로 비트열을 사용할 수 있으며, 비트열 리터럴은 2진수 형식이나 16진수 형식을 사용한다. 2진수 형식으로 사용할 때에는 다음과 같이 문자 **B** 뒤에 0과 1로 이루어진 문자열을 붙이거나, **0b** 뒤에 값을 붙여 표현한다.
```
    B'1010'
    0b1010
```
16진수 형식은 대문자 **X** 뒤에 0-9 그리고 A-F 문자로 이루어진 문자열을 붙이거나 **0x** 뒤에 값을 붙여 표현한다. 예를 들어, 아래는 앞에서 2진수로 표현한 것과 같은 값을 16진수로 나타낸 것이다.
```
    X'a'
    0xA
```
16진수에서 사용되는 문자는 대소문자를 구분하지 않는다. 즉, X'4f'와 X'4F'는 같은 값으로 간주한다.

**길이(Length)**

비트열이 테이블 칼럼에 사용될 때에는 최대 길이를 표시해야 한다. 비트열이 가질 수 있는 최대 길이는 1,073,741,823비트이다.

### VARBINARY(n)

비트열은 **VARBINARY** (*n*)으로 나타낸다. 여기서 *n* 은 최대 비트의 개수를 나타낸다. 만약, *n* 이 생략되면 최대 길이인 1,073,741,823으로 지정된다. 비트열은 8비트 단위로 왼쪽부터 값이 채워진다. 예를 들어, B'1'의 값을 입력하면 B'10000000'과 같은 값으로 출력된다. 따라서, 8비트 단위로 크기를 선언하고 8비트 단위로 값을 입력할 것을 권장한다.

VARBINARY(4)로 선언된 칼럼에 B'1'을 INSERT하면 응용 프로그램에서는 X'80'으로 출력된다.

-   비트열의 크기가 *n* 을 넘어설 경우에는 절삭되고 0으로 채워진다.
-   *n* 보다 작은 비트열이 저장될 때에도 나머지 부분이 0으로 채워지지 않는다.
-   *n* 은 0보다 큰 숫자여야 한다.
-   이 타입의 칼럼에 **DEFAULT** 속성이 지정될 수 있다.

``` sql
CREATE GLOBAL TABLE bitvar_tbl(id INT PRIMARY KEY, a1 VARBINARY, a2 VARBINARY(8));
INSERT INTO bitvar_tbl VALUES (1, B'1', B'1');
INSERT INTO bitvar_tbl VALUES (2, 0b1010, 0b1010);
INSERT INTO bitvar_tbl VALUES (3, 0xaa, 0xaa);
INSERT INTO bitvar_tbl(id, a1) VALUES (4, 0xaaa);
INSERT INTO bitvar_tbl(id, a2) VALUES (5, 0xaaa);
SELECT a1, a2 FROM bitvar_tbl;
```
```
  a1        a2        
======================
  X'80'     X'80'     
  X'a0'     X'a0'     
  X'aa'     X'aa'     
  X'aaa0'   NULL      
  NULL      X'aaa0'   
```

문자열 데이터 타입
------------------

Rye는 가변길이 문자열(character string) 타입을 지원한다.

-   가변길이 문자열 : **VARCHAR** (*n*)
-   **CHAR** (*n*) 은 **VARCHAR** (*n*) 의 별칭이다.

다음은 문자열 타입을 사용할 때 적용되는 규칙이다.

-   문자열은 작은 따옴표로 감싸서 표현한다. SQL 구문 관련 파라미터인 **ansi\_quotes** 의 값에 따라 문자열을 감싸는 부호로 큰 따옴표도 사용할 수 있다. **ansi\_quotes** 값을 no로 설정하면 큰 따옴표로 감싼 문자열을 식별자로 처리하지 않고 문자열로 처리한다. 기본값은 **yes** 이다. 자세한 설명은 stmt-type-parameters 를 참고한다.
-   ANSI 표준에 따라 두 개의 문자열 사이에 공간으로 취급할 수 있는 문자(예: 공백, 탭, 줄바꿈 등)가 있다면, 두 개의 문자열은 연속된 하나의 문자열로 취급된다. 예를 들면, 다음과 같이 두 개의 문자열 사이에 줄바꿈이 있는 경우가 있다.
```
        'abc'
        'def'
```

-   위 문자열은 아래에 있는 하나의 문자열과 동일하다.
```
        'abcdef'
```

-   작은 따옴표 자체를 문자열에 포함시키려면, 두 개의 작은 따옴표를 연속으로 입력하면 된다. 예를 들어, 아래의 왼쪽 문자열은 실제로 오른쪽과 같이 저장된다.
```
        '''abcde''fghij'       'abcde'fghij
```

-   모든 문자열에 대한 토큰의 최대 크기는 16KB이다.
-   특정 국가의 언어를 입력하고자 하는 경우 DB 생성 시 언어의 문자셋을 지정한다.

**길이(Length)**

문자의 개수를 지정한다.

**VARCHAR** 타입에서 지정할 수 있는 최대 길이는 1,073,741,823이다.


**문자셋(Character Set, charset)**

 문자셋(문자 집합)은 특정 문자(symbol)를 컴퓨터에 저장할 때, 어떠한 코드로 인코딩할 것인지에 대한 규칙이 정의된 집합을 의미한다. Rye가 사용할 문자셋은 DB 생성 시 지정될 수 있다.


### CHAR(n)

**VARCHAR** (*n*) 의 별칭이다.

### VARCHAR(n) 또는 CHAR VARYING(n)

가변길이 문자열은 **VARCHAR** (*n*)로 표현하며, 여기서 *n* 은 문자의 개수를 나타낸다. *n* 이 생략되면 길이는 최대 길이인 1,073,741,823로 지정된다.

문자열의 길이가 *n* 을 초과하면 오류를 반환한다.

**VARCHAR** (*n*)와 **CHARACTER VARYING** (*n*), **CHAR VARYING** (*n*)은 같은 의미로 사용된다.

-   **STRING** 은 **VARCHAR** (최대 길이)와 같다.
-   *n* 은 1부터 1,073,741,823(1G) 사이의 정수이다.
-   공백 값은 빈 따옴표('')로 처리하며, 이 경우 **LENGTH** 함수의 리턴 값은 0이다.
-   이 타입의 칼럼에 **DEFAULT** 속성이 지정될 수 있다.

### STRING

**STRING** 은 가변길이 문자열 데이터 타입이다. **STRING** 은 **VARCHAR** 를 최대 길이로 지정한 것과 같다. 즉 **STRING** 은 **VARCHAR** (1,073,741,823)과 동일하다.

### 따옴표 이스케이프

Rye는 문자열에 포함된 따옴표를 이스케이프(escape)하는 방법을 지원한다.

**rye-auto.conf** 의 시스템 파라미터 **ansi\_quotes**가 **no**로 설정되어 있으면 문자열을 감쌀 때 큰따옴표(")와 작은따옴표(') 둘 다 사용할 수 있다. **ansi\_quotes** 파라미터의 기본값은 **yes** 로, 문자열을 감쌀 때 작은따옴표만 사용할 수 있다.

   -   작은따옴표로 감싼 문자열에 포함된 작은따옴표는 두 개의 작은따옴표('')를 쓴다.
   -   큰따옴표로 감싼 문자열에 포함된 큰따옴표는 두 개의 큰따옴표("")를 쓴다. (**ansi\_quotes** 값이 no인 경우)
   -   큰따옴표로 감싼 문자열에 포함된 작은따옴표는 이스케이프하지 않아도 된다. (**ansi\_quotes** 값이 no인 경우)
   -   작은따옴표로 감싼 문자열에 포함된 큰따옴표는 이스케이프하지 않아도 된다.

묵시적 타입 변환
----------------

표현식 내에서 타입을 변환해야 할 때 자동으로 해당 타입으로 변환하는 것을 묵시적 타입 변환(implicit type conversion)이라고 한다.

**DATETIME** 타입을 **DATE** 타입이나 **TIME** 타입으로 변환하면 데이터의 일부가 유실될 수 있다. **DATE** 타입을 **DATETIME** 타입으로 변환하면, 시간은 '12:00:00 AM'으로 설정된다.

문자열 타입이나 정확한 수치형 타입을 부동소수점 수치형 타입으로 변환하면 값이 정확하지 않을 수 있다. 문자열 타입과 정확한 수치형 타입은 값을 표현하기 위해 십진 정밀도(decimal precision)를 사용하지만 부동소수점 수치형 타입은 이진 정밀도(binary precision)를 사용하기 때문이다.

Rye가 수행하는 묵시적 타입 변환은 다음과 같다.

**묵시적 타입 변환 표**

FROM \ TO | DATETIME | DATE | TIME  | DOUBLE | NUMERIC | BIGINT | INT | VARBINARY | VARCHAR 
 ---      | ---      | ---  | ---   | ---   | ---   | ---  		| ---   | ---  | ---
DATETIME  | - 	     | O 	|  O	|  		|  		| 			|  		|  		| O
DATE      | O	     | - 	|  		|  		|  		| 			|  		|  		| O
TIME      |  	     |  	|  -	|  		|  		| 			|  		|  		| O
DOUBLE    |  	     |  	|  		|  -	|  	O	| O 		|   O	|  		| O
NUMERIC   |  	     |  	|  		|  O	|  	-	| O			|  	O	|  		| O
BIGINT    |  	     |  	|  		|  O	|  	O	| - 		|  	O	|  		| O
INT       |  	     |  	|  		|  O	|  	O	| O			|  	_	|  		| O
VARBINARY |  	     |  	|  		|  		|  		| 			|  		|  _	| 
VARCHAR   | O 	     |  O	| O 	|  O 	| O 	| O 		|  	O	|  		| O

### 변환 규칙

#### INSERT와 UPDATE

영향을 받는 칼럼의 타입으로 값의 타입이 변환된다.

``` sql
CREATE GLOBAL TABLE t(i INT PRIMARY KEY);
INSERT INTO t VALUES('123');

SELECT * FROM t;
```
```
  i     
========
  123   
```

#### 함수

함수에 입력한 인자 값을 함수에서 지정한 타입으로 변환할 수 있으면 인자의 타입이 변환된다. 아래 함수에서 기대하는 입력 인자는 숫자이므로, 문자열을 숫자로 변환한다.

``` sql
SELECT MOD('123','2');
```
```
  mod('123', '2')   
====================
  1.0               
```
함수는 인자로 여러 타입의 값을 입력받을 수 있는데, 함수에서 지정하지 않은 타입의 값이 전달되면 다음의 우선순위에 따라 타입이 변환된다.

-   날짜/시간 타입 ( **DATETIME** > **DATE** > **TIME** )
-   정확한 수치형 타입 ( **NUMERIC** > **BIGINT** > **INT** )

#### 비교 연산

다음은 비교 연산자의 피연산자 타입에 따른 변환 규칙이다.

<style type="text/css">
</style>
<table class="tg">
  <tr>
    <th class="tg-yw4l"> operand1 타입 </th>
    <th class="tg-yw4l"> operand2 타입 </th>
    <th class="tg-yw4l"> 변환 </th>
    <th class="tg-yw4l"> 비교 타입 </th>
  </tr>
  <tr>
    <td class="tg-yw4l" rowspan="2"> 수치형 타입 </td>
    <td class="tg-yw4l"> 수치형 타입 </td>
    <td class="tg-yw4l"> 없음 </td>
    <td class="tg-yw4l"> NUMERIC </td>
  </tr>
  <tr>
    <td class="tg-yw4l"> 문자열 타입 </td>
    <td class="tg-yw4l"> operand2 를 DOUBLE 로 변환 </td>
    <td class="tg-yw4l"> NUMERIC </td>
  </tr>
  <tr>
    <td class="tg-yw4l" rowspan="3"> 문자열 타입 </td>
    <td class="tg-yw4l"> 수치형 타입 </td>
    <td class="tg-yw4l"> operand1 을 DOUBLE 로 변환 </td>
    <td class="tg-yw4l"> NUMERIC </td>
  </tr>
  <tr>
    <td class="tg-yw4l"> 문자열 타입 </td>
    <td class="tg-yw4l"> 없음 </td>
    <td class="tg-yw4l"> 문자열 </td>
  </tr>
  <tr>
    <td class="tg-yw4l"> 날짜/시간 타입 </td>
    <td class="tg-yw4l"> operand1 을 날짜/시간 타입으로 변환 </td>
    <td class="tg-yw4l"> 날짜/시간 </td>
  </tr>
  <tr>
    <td class="tg-yw4l" rowspan="2"> 날짜/시간 타입 </td>
    <td class="tg-yw4l"> 문자열 타입 </td>
    <td class="tg-yw4l"> operand2 를 날짜/시간 타입으로 변환 </td>
    <td class="tg-yw4l"> 날짜/시간 </td>
  </tr>
  <tr>
    <td class="tg-yw4l"> 날짜/시간 </td>
    <td class="tg-yw4l"> 없음 </td>
    <td class="tg-yw4l"> 날짜/시간 </td>
  </tr>
</table>

다음은 비교 연산에서 묵시적 타입 변환의 예이다.

-   **수치형 타입과 문자열 타입 피연산자**

    문자열 타입 피연산자가 **DOUBLE** 로 변환된다.

    ``` sql
    CREATE GLOBAL TABLE t1(i INT PRIMARY KEY, s STRING);
    INSERT INTO t1 VALUES(1,'1'),(2,'2'),(3,'3'),(4,'4'), (12,'12');

    SELECT i FROM t1 WHERE i < '11.3';
    ```
    ```
      i   
    ======
      1   
      2   
      3   
      4   
    ```

    ``` sql
    SELECT ('2' <= 11);
    ```
    ```
      ('2'<=11)   
    ==============
      1           
    ```
    
-   **문자열 타입과 날짜/시간 타입 피연산자**

    문자열 타입 피연산자가 날짜/시간 타입으로 변환된다.

    ``` sql
    SELECT ('2010-01-01' < date'2010-02-02');
    ```
    ```
      ('2010-01-01'<date '2010-02-02')   
    =====================================
      1                                  
    ```
    ``` sql
    SELECT (date'2010-02-02' >= '2010-01-01');
    ```
    ```
      (date '2010-02-02'>='2010-01-01')   
    ======================================
      1                                   
    ```
   
-   **문자열 타입 칼럼과 수치형 타입 값 피연산자**

    문자열 타입 값이 숫자형 타입으로 변환된다.

    ``` sql
    SELECT s FROM t1 WHERE s > 11;
    ```
    ```
      s      
    =========
      '12'   
    ```
    ``` sql
    SELECT s FROM t1 WHERE s BETWEEN 11 AND 33;
    ```
    ```
      s      
    =========
      '12'   
    ```
    
-   **문자열 타입 칼럼과 날짜/시간 타입 값 피연산자**

    문자열 타입 값이 날짜/시간 타입으로 변환된다.

    ``` sql
    CREATE GLOBAL TABLE t2 (id INT PRIMARY KEY, s STRING);
    INSERT INTO t2 VALUES (1, '1998-01-01'), (2, '1999-01-01'), (3, '2000-01-01');
    SELECT s FROM t2;
    ```
    ```
      s              
    =================
      '1998-01-01'   
      '1999-01-01'   
      '2000-01-01'   
    ```
    ``` sql
    SELECT s FROM t2 WHERE s <= date'1998-02-02';
    ```
    ```
      s              
    =================
      '1998-01-01'   
    ```

#### 범위 연산

-   **수치형 타입과 문자열 타입 피연산자**

    문자열 타입 피연산자가 **DOUBLE** 로 변환된다.

    ``` sql
    CREATE GLOBAL TABLE t3 (i INT PRIMARY KEY);
    INSERT INTO t3 VALUES (1), (2), (3), (4);
    SELECT i FROM t3 WHERE i <= '11';
    ```
    ```
      i   
    ======
      1   
      2   
      3   
      4   
    ```
    
-   **문자열 타입과 날짜/시간 타입 피연산자**

    문자열 타입 피연산자가 날짜/시간 타입으로 변환된다.

    ``` sql
    SELECT s FROM t2;
    ```
    ```
      s              
    =================
      '1998-01-01'   
      '1999-01-01'   
      '2000-01-01'   
    ```
    ``` sql
    SELECT s FROM t2 WHERE s <= date'1998-02-02';
    ```
    ```
      s              
    =================
      '1998-01-01'   
    ```
    해당 타입으로 변환할 수 없으면 오류를 반환한다.

#### 산술 연산

-   **수치형 타입 피연산자**

    수치형 타입의 피연산자가 주어지고 타입이 서로 다르면, 두 타입을 비교하여 우선순위가 높은 쪽의 타입으로 변환된다.

-   **수치형 타입과 문자열 타입 피연산자**

    수치형 타입과 문자열 타입이 피연산자이면 다음 규칙이 적용된다.

    -   문자열은 가능하면 **DOUBLE**로 변환된다.
    -   결과 타입은 **DOUBLE**이다.

    ``` sql
    SELECT 4 + '5.2';
    ```
    ```
      4+'5.2'   
    ============
      9.2       
    ```

    ``` sql
    SELECT '2002-01-01'+1;
    ```
    ```
ERROR: Cannot coerce value of type "character varying" to type "double".
    ```

-   **문자열 타입 피연산자**

    두 문자열을 곱하거나 나누거나 빼면 숫자로 변환되며, 결과로 **DOUBLE** 타입의 값을 반환한다.

    ``` sql
    SELECT '3'*'2';
    ```
    ```
      '3'*'2'   
    ============
      6.0       
    ```
    두 개의 문자열이 숫자로 변환 가능하면, 두 숫자를 더하여 **DOUBLE** 타입의 값을 반환한다.

    ``` sql
        SELECT '1'+'1';
    ```
    ```
      '1'+'1'   
    ============
      2.0       
    ```
    해당 타입으로 변환할 수 없으면 오류를 반환한다.


